#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

难度中等

```
执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
内存消耗：36.9 MB, 在所有 Java 提交中击败了89.47%的用户
```



给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

 

**进阶：**

- 你可以不使用代码库中的排序函数来解决这道题吗？
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

 

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**示例 3：**

```
输入：nums = [0]
输出：[0]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`



```java
class Solution {
    /*
    这里一定要注意的是不要把问题复杂化
    一开始我想要考虑三个指针变化的情况，完全理不出头绪来，但是题解就很清晰，左右指针l、r是不变的，只需要负责位置范围的标定，但是中间的遍历指针i则是划分节点的情况为0则和l指针交换，为2则和r指针交换
    这样就很清楚了，只要考虑一个变量的三种情况即可，而不必在几个指针情况下进行排列组合
    */
    public void sortColors(int[] nums) {
        int len = nums.length;
        int l = 0, r = len - 1;
        for(int i=0; i<len; ++i) {
            // 这里是为了避免出现从nums[r]交换过来的仍然是2的情况
            while(i <= r && nums[i] == 2) {
                swap(nums, i, r--);
            }
            // 交换当前i和最开始的为1的地方，这样的话，还要使得l++，然后交换结束后回到主循环，i++
            if(nums[i] == 0) {
                swap(nums, i, l++);
            }
        }
    }

    public void swap(int[] nums, int l, int r) {
        int tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
    }
}
```

